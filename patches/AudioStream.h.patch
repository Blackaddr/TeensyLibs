diff --git a/teensy4/AudioStream.h b/teensy4/AudioStream.h
index 77f136e..becfd2a 100644
--- a/teensy4/AudioStream.h
+++ b/teensy4/AudioStream.h
@@ -64,11 +64,13 @@
 class AudioStream;
 class AudioConnection;
 
+// audio_block_struct stores control information, the actual
+// data buffer is allocated separately
 typedef struct audio_block_struct {
 	uint8_t  ref_count;
 	uint8_t  reserved1;
 	uint16_t memory_pool_index;
-	int16_t  data[AUDIO_BLOCK_SAMPLES];
+	int16_t *data;
 } audio_block_t;
 
 
@@ -102,10 +104,13 @@ protected:
 	bool isConnected;
 };
 
-
+// Create the array of num audio_block_t for control.
+// Create a DMA 32-byte aligned contiguous block of memory of the required size.
+// Call the initialize_memory() function to finish setting up the audio buffer pool
 #define AudioMemory(num) ({ \
 	static DMAMEM audio_block_t data[num]; \
-	AudioStream::initialize_memory(data, num); \
+	DMAMEM __attribute__((aligned(32))) static int16_t dataBuffers[AUDIO_BLOCK_SAMPLES*num]; \
+	AudioStream::initialize_memory(data, num, dataBuffers); \
 })
 
 #define CYCLE_COUNTER_APPROX_PERCENT(n) (((float)((uint32_t)(n) * 6400u) * (float)(AUDIO_SAMPLE_RATE_EXACT / AUDIO_BLOCK_SAMPLES)) / (float)(F_CPU_ACTUAL))
@@ -141,7 +146,7 @@ public:
 			cpu_cycles_max = 0;
 			numConnections = 0;
 		}
-	static void initialize_memory(audio_block_t *data, unsigned int num);
+	static void initialize_memory(audio_block_t *data, unsigned int num, int16_t *dataBuffers=nullptr);
 	float processorUsage(void) { return CYCLE_COUNTER_APPROX_PERCENT(cpu_cycles); }
 	float processorUsageMax(void) { return CYCLE_COUNTER_APPROX_PERCENT(cpu_cycles_max); }
 	void processorUsageMaxReset(void) { cpu_cycles_max = cpu_cycles; }
